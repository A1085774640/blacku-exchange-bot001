# blacku-exchange-bot001
import logging
import random
from datetime import datetime
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    CallbackQueryHandler,
    ContextTypes,
    MessageHandler,
    filters,
    ConversationHandler
)

# è®¾ç½®æ—¥å¿—
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", 
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# æœºå™¨äººTokenï¼ˆä»BotFatherè·å–ï¼‰
TOKEN = "YOUR_BOT_TOKEN"

# å¯¹è¯çŠ¶æ€
CALCULATING, PLACING_ORDER, CONFIRMING_ORDER, ENTERING_ADDRESS = range(4)

# æ±‡ç‡è¡¨
RATE_TABLE = {
    (1, 99): 1.1,
    (100, 199): 1.3,
    (200, 499): 1.5,
    (500, 999): 1.7,
    (1000, 4999): 2.0
}

# æ”¯ä»˜åœ°å€ï¼ˆå®é™…ä½¿ç”¨æ—¶è¯·æ›¿æ¢ï¼‰
PAYMENT_ADDRESS = "TUPJUk6g7onqnD9xUVTYj7UKFMadXk8bFg"

# ===== ä¸»èœå• =====
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """å‘é€ä¸»èœå•"""
    keyboard = [
        [InlineKeyboardButton("é»‘Uæ±‡ç‡", callback_data="blacku_rate")],
        [InlineKeyboardButton("åœ¨çº¿ä¸‹å•", callback_data="place_order")]
    ]
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        "æ¬¢è¿ä½¿ç”¨é»‘Uæ±‡ç‡æœºå™¨äººï¼è¯·é€‰æ‹©åŠŸèƒ½ï¼š",
        reply_markup=reply_markup
    )
    return ConversationHandler.END

# ===== é»‘Uæ±‡ç‡åŠŸèƒ½ =====
async def show_blacku_rate(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """æ˜¾ç¤ºé»‘Uæ±‡ç‡ç•Œé¢"""
    query = update.callback_query
    await query.answer()
    
    # æ„å»ºæ±‡ç‡è¡¨æ–‡æœ¬
    rate_text = "æ ¹æ®ä¸‹å•é‡‘é¢ï¼Œå¯¹åº”æ±‡ç‡ï¼š\nâ–â–â–â–â–â–â–â–â–â–â–\n"
    for (min_val, max_val), rate in RATE_TABLE.items():
        rate_text += f"é‡‘é¢ï¼š{min_val}ï½{max_val}U\tï½œæ±‡ç‡ï¼š{rate}\n"
    rate_text += "â–â–â–â–â–â–â–â–â–â–â–\n"
    rate_text += "è‡ªåŠ¨è®¡ç®—åˆ©æ¶¦ï¼Œä¾‹å¦‚è¾“å…¥ï¼š200"
    
    # æ·»åŠ è®¡ç®—æŒ‰é’®
    keyboard = [[InlineKeyboardButton("ç‚¹å‡»è®¡ç®—é»‘Uæ±‡ç‡", callback_data="calculate_rate")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(
        text=rate_text,
        reply_markup=reply_markup
    )

# ===== å¯åŠ¨æ±‡ç‡è®¡ç®— =====
async def start_calculate(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """å¯åŠ¨æ±‡ç‡è®¡ç®—æµç¨‹"""
    query = update.callback_query
    await query.answer()
    
    await query.edit_message_text(
        text="è¯·è¾“å…¥æ‚¨è¦è´­ä¹°çš„æ•°é‡ï¼ˆä¸æ”¯æŒå°æ•°ä½ï¼‰ï¼š",
        reply_markup=None
    )
    
    return CALCULATING

# ===== å¤„ç†æ±‡ç‡è®¡ç®— =====
async def calculate_profit(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """è®¡ç®—å¹¶æ˜¾ç¤ºåˆ©æ¶¦"""
    user_input = update.message.text
    
    try:
        amount = int(user_input)
        
        # æŸ¥æ‰¾é€‚ç”¨æ±‡ç‡
        applicable_rate = None
        for (min_val, max_val), rate in RATE_TABLE.items():
            if min_val <= amount <= max_val:
                applicable_rate = rate
                break
        
        if applicable_rate is None:
            response = "âŒ é‡‘é¢è¶…å‡ºèŒƒå›´ï¼Œè¯·è¾“å…¥1-4999ä¹‹é—´çš„æ•´æ•°"
        else:
            profit = amount * applicable_rate
            response = (
                f"è´­ä¹°æ•°é‡: {amount}U\n"
                f"é€‚ç”¨æ±‡ç‡: {applicable_rate}\n"
                f"é¢„æœŸåˆ©æ¶¦: {profit:.2f}U\n\n"
                f"æ„Ÿè°¢ä½¿ç”¨!"
            )
    except ValueError:
        response = "âŒ è¾“å…¥æ— æ•ˆï¼Œè¯·è¾“å…¥æ•´æ•°ï¼ˆå¦‚: 200ï¼‰"
    
    await update.message.reply_text(response)
    return ConversationHandler.END

# ===== å¯åŠ¨åœ¨çº¿ä¸‹å• =====
async def start_place_order(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """å¯åŠ¨åœ¨çº¿ä¸‹å•æµç¨‹"""
    query = update.callback_query
    await query.answer()
    
    await query.edit_message_text(
        text="è¯·è¾“å…¥æ‚¨è¦è´­ä¹°çš„æ•°é‡ï¼ˆä¸æ”¯æŒå°æ•°ä½ï¼‰ï¼š",
        reply_markup=None
    )
    
    return PLACING_ORDER

# ===== å¤„ç†ä¸‹å•æ•°é‡ =====
async def process_order_quantity(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """å¤„ç†è®¢å•æ•°é‡å¹¶è®¡ç®—é‡‘é¢"""
    user_input = update.message.text
    
    try:
        amount = int(user_input)
        context.user_data['order_quantity'] = amount
        
        # æŸ¥æ‰¾é€‚ç”¨æ±‡ç‡
        applicable_rate = None
        for (min_val, max_val), rate in RATE_TABLE.items():
            if min_val <= amount <= max_val:
                applicable_rate = rate
                break
        
        if applicable_rate is None:
            response = "âŒ é‡‘é¢è¶…å‡ºèŒƒå›´ï¼Œè¯·è¾“å…¥1-4999ä¹‹é—´çš„æ•´æ•°"
            await update.message.reply_text(response)
            return ConversationHandler.END
        else:
            profit = amount * applicable_rate
            context.user_data['order_profit'] = profit
            context.user_data['order_rate'] = applicable_rate
            
            keyboard = [
                [InlineKeyboardButton("å–æ¶ˆä¸‹å•", callback_data="cancel_order")],
                [InlineKeyboardButton("ç¡®è®¤è®¢å•", callback_data="confirm_order")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await update.message.reply_text(
                f"è®¢å•è¯¦æƒ…ï¼š\n"
                f"è´­ä¹°æ•°é‡: {amount}U\n"
                f"é€‚ç”¨æ±‡ç‡: {applicable_rate}\n"
                f"æ‚¨å°†æ”¶åˆ°: {profit:.2f}U\n\n"
                f"è¯·ç¡®è®¤è®¢å•ï¼š",
                reply_markup=reply_markup
            )
            
            return CONFIRMING_ORDER
    except ValueError:
        await update.message.reply_text("âŒ è¾“å…¥æ— æ•ˆï¼Œè¯·è¾“å…¥æ•´æ•°ï¼ˆå¦‚: 200ï¼‰")
        return ConversationHandler.END

# ===== ç¡®è®¤è®¢å• =====
async def confirm_order(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """ç¡®è®¤è®¢å•å¹¶è¯·æ±‚æ¥æ”¶åœ°å€"""
    query = update.callback_query
    await query.answer()
    
    await query.edit_message_text(
        text="è¯·è¾“å…¥æ‚¨çš„USDTï¼ˆTRC20)æ¥æ”¶åœ°å€ï¼š",
        reply_markup=None
    )
    
    return ENTERING_ADDRESS

# ===== å–æ¶ˆè®¢å• =====
async def cancel_order(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """å–æ¶ˆè®¢å•"""
    query = update.callback_query
    await query.answer()
    
    await query.edit_message_text(
        text="è®¢å•å·²å–æ¶ˆ",
        reply_markup=None
    )
    
    return ConversationHandler.END

# ===== å¤„ç†æ¥æ”¶åœ°å€ =====
async def process_receiving_address(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """å¤„ç†æ¥æ”¶åœ°å€å¹¶ç”Ÿæˆè®¢å•"""
    address = update.message.text
    context.user_data['receiving_address'] = address
    
    # ç®€å•éªŒè¯åœ°å€æ ¼å¼ï¼ˆå®é™…åº”ä½¿ç”¨æ›´å¤æ‚çš„éªŒè¯ï¼‰
    if not address.startswith("T") or len(address) < 25:
        await update.message.reply_text("âŒ åœ°å€æ ¼å¼æ— æ•ˆï¼Œè¯·è¾“å…¥æœ‰æ•ˆçš„TRC20åœ°å€")
        return ConversationHandler.END
    
    # ç”Ÿæˆè®¢å•å·ï¼ˆæ—¶é—´æˆ³+éšæœºæ•°ï¼‰
    order_id = f"{datetime.now().strftime('%Y%m%d%H%M%S')}{random.randint(1000, 9999)}"
    
    # è·å–è®¢å•è¯¦æƒ…
    quantity = context.user_data['order_quantity']
    profit = context.user_data['order_profit']
    rate = context.user_data['order_rate']
    
    # æ„å»ºè®¢å•æ¶ˆæ¯
    order_message = (
        f"è®¢å•ç¼–å·ï¼š{order_id}\n\n"
        f"æ‚¨ä¼šæ”¶åˆ°ï¼š{profit:.2f}U\n"
        f"æ¥æ”¶åœ°å€ï¼šè¯·æ ¸å¯¹å6ä½\n"
        f"{address[-6:]}\n"
        f"â–â–â–â–â–â–â–â–â–â–â–â–\n"
        f"æ”¯ä»˜é‡‘é¢ï¼š{quantity}U\n\n"
        f"æ”¯ä»˜åœ°å€ï¼š\n{PAYMENT_ADDRESS}\n\n"
        f"ğŸ‘† ç‚¹ä¸€ä¸‹å¤åˆ¶ã€æ”¯ä»˜åœ°å€ / é‡‘é¢ã€‘\n"
        f"âš ï¸ æ³¨æ„é‡‘é¢ã€å®åˆ°è´¦é‡‘é¢å¿…é¡»ä¸€è‡´ã€‘\n"
        f"â–â–â–â–â–â–â–â–â–â–â–â–\n"
        f"æç¤ºï¼š\n"
        f"â–«ï¸æ”¯ä»˜å‰ï¼Œå…ˆæ ¸å¯¹æ”¯ä»˜åœ°å€å6ä½\n"
        f"â–«ï¸è®¢å•æ”¯ä»˜è¶…æ—¶ä¸ºï¼ˆ15åˆ†é’Ÿï¼‰\n"
        f"â–«ï¸è¯·å‹¿ä¿å­˜æ”¯ä»˜åœ°å€, ä¸å®šæœŸæ›´æ¢\n"
        f"â–«ï¸æ”¯ä»˜æˆåŠŸåç­‰å¾…60ç§’, åŒºå—é“¾è¯»å–åˆ°æ‚¨æ”¯ä»˜çš„æ•°æ®, ç³»ç»Ÿè‡ªåŠ¨å®Œæˆå›è°ƒ"
    )
    
    await update.message.reply_text(order_message)
    
    # æ¸…ç†ç”¨æˆ·æ•°æ®
    context.user_data.clear()
    
    return ConversationHandler.END

# ===== é”™è¯¯å¤„ç† =====
async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """è®°å½•é”™è¯¯"""
    logger.error(msg="å¤„ç†æ›´æ–°æ—¶å‡ºé”™:", exc_info=context.error)

# ===== ä¸»å‡½æ•° =====
def main() -> None:
    """å¯åŠ¨æœºå™¨äºº"""
    application = Application.builder().token(TOKEN).build()
    
    # æ·»åŠ å‘½ä»¤å¤„ç†å™¨
    application.add_handler(CommandHandler("start", start))
    
    # æ·»åŠ é»‘Uæ±‡ç‡å¯¹è¯å¤„ç†å™¨
    rate_conv_handler = ConversationHandler(
        entry_points=[
            CallbackQueryHandler(show_blacku_rate, pattern="^blacku_rate$"),
            CallbackQueryHandler(start_calculate, pattern="^calculate_rate$")
        ],
        states={
            CALCULATING: [MessageHandler(filters.TEXT & ~filters.COMMAND, calculate_profit)]
        },
        fallbacks=[CommandHandler("start", start)],
        map_to_parent={
            ConversationHandler.END: ConversationHandler.END
        }
    )
    
    # æ·»åŠ åœ¨çº¿ä¸‹å•å¯¹è¯å¤„ç†å™¨
    order_conv_handler = ConversationHandler(
        entry_points=[
            CallbackQueryHandler(start_place_order, pattern="^place_order$")
        ],
        states={
            PLACING_ORDER: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_order_quantity)],
            CONFIRMING_ORDER: [
                CallbackQueryHandler(cancel_order, pattern="^cancel_order$"),
                CallbackQueryHandler(confirm_order, pattern="^confirm_order$")
            ],
            ENTERING_ADDRESS: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_receiving_address)]
        },
        fallbacks=[CommandHandler("start", start)],
        map_to_parent={
            ConversationHandler.END: ConversationHandler.END
        }
    )
    
    application.add_handler(rate_conv_handler)
    application.add_handler(order_conv_handler)
    
    # æ·»åŠ é”™è¯¯å¤„ç†å™¨
    application.add_error_handler(error_handler)
    
    # å¯åŠ¨æœºå™¨äºº
    application.run_polling()

if __name__ == "__main__":
    main()
